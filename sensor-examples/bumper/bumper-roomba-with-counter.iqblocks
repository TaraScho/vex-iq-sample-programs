{"mode":"Blocks","hardwareTarget":"brain","workspace":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"_2.^beQjx|FGt38A,8(E\">myVariable</variable><variable id=\"B3v!3JP5ZTf/Sc;$yKAK\">Optcolor</variable><variable id=\"K9WEz.gQtGg}?.#7G9mF\">Bump_Count</variable></variables><comment id=\"^S7}B$!N1wqK_QVs?8!L\" x=\"526\" y=\"-344\" h=\"425.98199462890625\" w=\"762.6083984375\">Name: \"Roomba\" style program to demonstrate the BUMPER sensor\n\nThis program uses the bumper sensor to navigate around obstacles. The robot drives forward until the bumper is pressed. If the bumper is pressed, the robot backs up and turns right until it can drive forward again. \n\nThis program also demonstrates variables by keeping a count of each time the bumper is pressed. Whenever the bumper is pressed, the Bump_Count variable is incremented by one and a message prints to the brain. \n\nThe Increment_Bump_Count block is used to the reuse\n the lines of code that increment the bump count.\nConcepts:\n- Bumper sensor\n- variables\n- Blocks\n\nBrain Supported: 2nd generation\n\nConfiguration:\nBaseBot with Sensors (Drivetrain 2-motor, Inertial)\nLeft Motor in Port 7 \nRight Motor in Port 12\nTouchLED in Port 11\nOptical Sensor in Port 10\nDistance Sensor in Port 6\nBumper Switch in Port 5</comment><block type=\"iq_events_when_started\" id=\".NsXwU_L.OuU1l7Sho$F\" x=\"253\" y=\"-99\"><next><block type=\"iq_variables_set_variable\" id=\"s%}pZ$M36?t`,aYfM9c%\"><field name=\"VARIABLE\" id=\"K9WEz.gQtGg}?.#7G9mF\">Bump_Count</field><value name=\"VALUE\"><shadow type=\"math_number\" id=\"5?!q_+,u`;!|oEIn^H($\"><field name=\"NUM\">0</field></shadow></value><next><block type=\"iq_control_forever\" id=\"-1%]%)Z@U)Do9|.t-)wJ\"><statement name=\"SUBSTACK\"><block type=\"iq_drivetrain_drive\" id=\"SEL.}epZ2Zb9~;$d3l,g\"><field name=\"DIRECTION\">fwd</field><next><block type=\"iq_control_wait_until\" id=\"kn`m:tK/M@aBS6pD^}y?\"><value name=\"CONDITION\"><block type=\"iq_sensing_pressing_bumper\" id=\"b^p_Hhqj/Ebpt*k::[V;\"><field name=\"BUMPER\">Bumper5</field></block></value><next><block type=\"procedures_call\" id=\"ByKoZZ:SvOdoWV!(bfg0\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" proccode=\"Increment_Bump_Count %n\" proceduredefid=\"4.3KvZLH{?#[%9v~ipyi\" argumentids=\"[&quot;XG/**]{H+*Ls0909!!5^&quot;]\" warp=\"false\"></mutation><value name=\"XG/**]{H+*Ls0909!!5^\"><shadow type=\"math_number\" id=\"z(]4KJ$yuIY7lcbfCgvu\"><field name=\"NUM\">1</field></shadow></value><next><block type=\"iq_drivetrain_drive_for\" id=\"D,f|+%@Sbg}KiDWQ;%gH\"><field name=\"DIRECTION\">rev</field><field name=\"UNITS\">in</field><field name=\"anddontwait_mutator\">false</field><value name=\"AMOUNT\"><shadow type=\"math_number\" id=\"AGStmTzo$@rsS!FXHiPS\"><field name=\"NUM\">3</field></shadow></value><next><block type=\"iq_drivetrain_turn_for\" id=\"@Wx?VT2G-fN`@r_kiP!#\"><field name=\"TURNDIRECTION\">right</field><field name=\"anddontwait_mutator\">false</field><value name=\"AMOUNT\"><shadow type=\"math_number\" id=\"v|4iJUAa~uqR$wJe7%14\"><field name=\"NUM\">90</field></shadow></value></block></next></block></next></block></next></block></next></block></statement></block></next></block></next></block><block type=\"procedures_definition\" id=\"MOJ(k:z?3^U]YVWlmAn{\" x=\"770\" y=\"190\"><statement name=\"custom_block\"><shadow type=\"procedures_prototype\" id=\"~NU3jai!(o7vDT*s**eN\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" proccode=\"Increment_Bump_Count %n\" proceduredefid=\"~NU3jai!(o7vDT*s**eN\" argumentids=\"[&quot;XG/**]{H+*Ls0909!!5^&quot;]\" argumentnames=\"[&quot;Count&quot;]\" argumentdefaults=\"[&quot;todo&quot;]\" argumenttypes=\"[&quot;n&quot;]\" warp=\"false\"></mutation><value name=\"XG/**]{H+*Ls0909!!5^\"><shadow type=\"argument_reporter_number\" id=\"Kw:3GX[MVI97Dw!mFU3|\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" funcname=\"Increment_Bump_Count_Count\" argumentid=\"XG/**]{H+*Ls0909!!5^\" proceduredefid=\"~NU3jai!(o7vDT*s**eN\"></mutation><field name=\"VALUE\">Count</field></shadow></value></shadow></statement><next><block type=\"iq_variables_change_variable\" id=\"=l2jT[0lRyl1]rF^j/N.\"><field name=\"VARIABLE\" id=\"K9WEz.gQtGg}?.#7G9mF\">Bump_Count</field><value name=\"VALUE\"><shadow type=\"math_number\" id=\"n7+63$_i3Ei*-*s;?vCo\"><field name=\"NUM\">1</field></shadow></value><next><block type=\"iq_looks_print_new\" id=\"Krr0%v-%i!eOG|H8gS3~\"><field name=\"TARGET\">Brain</field><field name=\"andsetcursortonextrow_mutator\">false</field><value name=\"DATA\"><shadow type=\"text\" id=\"upwxoEwVELZWO/C,*OKu\"><field name=\"TEXT\">BUMP</field></shadow></value><next><block type=\"iq_looks_print_new\" id=\"FK*!j3H3jG[NIOqz8XQI\"><field name=\"TARGET\">Brain</field><field name=\"andsetcursortonextrow_mutator\">false</field><value name=\"DATA\"><shadow type=\"text\" id=\"wzi[+xXo0#ObN~REW!-d\"><field name=\"TEXT\">VEXcode</field></shadow><block type=\"iq_variables_variable\" id=\"c[ts!%Lv4OPO$f2@v;3f\"><field name=\"VARIABLE\" id=\"K9WEz.gQtGg}?.#7G9mF\">Bump_Count</field></block></value><next><block type=\"iq_looks_next_row_new\" id=\"._$el7o`usS-Nz5|x,27\"><field name=\"TARGET\">Brain</field></block></next></block></next></block></next></block></next></block></xml>","robotConfig":[{"port":[7,12],"name":"Drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"2-motor","wheelSize":"200mm","gearRatio":"1:1","direction":"fwd","gyroType":"integrated","width":"173","unit":"mm","wheelbase":"76","wheelbaseUnit":"mm","xOffset":"0","yOffset":"0","thetaOffset":"0"},"triportSourcePort":22},{"port":[11],"name":"TouchLED11","customName":false,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[10],"name":"Optical10","customName":false,"deviceType":"Optical","deviceClass":"optical","setting":{},"triportSourcePort":22},{"port":[5],"name":"Bumper5","customName":true,"deviceType":"Bumper","deviceClass":"bumper","setting":{},"triportSourcePort":22},{"port":[6],"name":"Distance6","customName":false,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"Second","v5SoundsEnabled":false,"downloadLanguage":"python","cppStatus":"true","cpp":"// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ninertial BrainInertial = inertial();\nmotor LeftDriveSmart = motor(PORT7, 1, false);\nmotor RightDriveSmart = motor(PORT12, 1, true);\n\nsmartdrive Drivetrain = smartdrive(LeftDriveSmart, RightDriveSmart, BrainInertial, 200);\n\ntouchled TouchLED11 = touchled(PORT11);\noptical Optical10 = optical(PORT10);\nbumper Bumper5 = bumper(PORT5);\ndistance Distance6 = distance(PORT6);\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  wait(100,msec);\n  double xAxis = BrainInertial.acceleration(xaxis) * 1000;\n  double yAxis = BrainInertial.acceleration(yaxis) * 1000;\n  double zAxis = BrainInertial.acceleration(zaxis) * 1000;\n  // Combine these values into a single integer\n  int seed = int(\n    xAxis + yAxis + zAxis\n  );\n  // Set the seed\n  srand(seed); \n}\n\nbool vexcode_initial_drivetrain_calibration_completed = false;\nvoid calibrateDrivetrain() {\n  wait(200, msec);\n  Brain.Screen.print(\"Calibrating\");\n  Brain.Screen.newLine();\n  Brain.Screen.print(\"Inertial\");\n  BrainInertial.calibrate();\n  while (BrainInertial.isCalibrating()) {\n    wait(25, msec);\n  }\n  vexcode_initial_drivetrain_calibration_completed = true;\n  // Clears the screen and returns the cursor to row 1, column 1.\n  Brain.Screen.clearScreen();\n  Brain.Screen.setCursor(1, 1);\n}\n\nvoid vexcodeInit() {\n\n  // Calibrate the Drivetrain\n  calibrateDrivetrain();\n\n  // Initializing random seed.\n  initializeRandomSeed(); \n}\n\n\n// Generated code.\n\n// Include the IQ Library\n#include \"vex.h\"\n  \n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n// User defined function\nvoid myblockfunction_Increment_Bump_Count_Count(double myblockfunction_Increment_Bump_Count_Count__Count);\n\nint Brain_precision = 0, Console_precision = 0;\n\nfloat myVariable, Optcolor, Bump_Count;\n\n// Used to find the format string for printing numbers with the\n// desired number of decimal places\nconst char* printToBrain_numberFormat() {\n  // look at the current precision setting to find the format string\n  switch(Brain_precision){\n    case 0:  return \"%.0f\"; // 0 decimal places (1)\n    case 1:  return \"%.1f\"; // 1 decimal place  (0.1)\n    case 2:  return \"%.2f\"; // 2 decimal places (0.01)\n    case 3:  return \"%.3f\"; // 3 decimal places (0.001)\n    default: return \"%f\"; // use the print system default for everthing else\n  }\n}\n\n// User defined function\nvoid myblockfunction_Increment_Bump_Count_Count(double myblockfunction_Increment_Bump_Count_Count__Count) {\n  Bump_Count = Bump_Count + 1.0;\n  Brain.Screen.print(\"BUMP\");\n  Brain.Screen.print(printToBrain_numberFormat(), static_cast<float>(Bump_Count));\n  Brain.Screen.newLine();\n}\n\n// \"when started\" hat block\nint whenStarted1() {\n  Bump_Count = 0.0;\n  while (true) {\n    Drivetrain.drive(forward);\n    waitUntil(Bumper5.pressing());\n    myblockfunction_Increment_Bump_Count_Count(1.0);\n    Drivetrain.driveFor(reverse, 3.0, inches, true);\n    Drivetrain.turnFor(right, 90.0, degrees, true);\n  wait(20, msec);\n  }\n  return 0;\n}\n\n\nint main() {\n  // Initializing Robot Configuration. DO NOT REMOVE!\n  vexcodeInit();\n\n  whenStarted1();\n}","target":"Physical"}